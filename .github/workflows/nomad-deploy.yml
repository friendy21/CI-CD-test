# .github/workflows/nomad-deploy.yml
name: Nomad Deployment Pipeline

on:
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'production'
        type: choice
        options:
          - production
          - staging
          - development

env:
  REGISTRY: docker.io
  IMAGE_NAME: friendy21/cicd-nomad-app
  NOMAD_VERSION: 1.7.5
  NOMAD_ADDR: http://137.184.85:4646 

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    outputs:
      image-tag: ${{ steps.meta.outputs.version }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=sha,prefix={{branch}}-
          type=raw,value={{date 'YYYYMMDD-HHmmss'}}-{{sha}}
          type=raw,value=latest,enable={{is_default_branch}}
    
    - name: Build and Push Docker Image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
        build-args: |
          VERSION=${{ github.sha }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
    
    - name: Generate deployment manifest
      run: |
        cat > deployment-manifest.json <<EOF
        {
          "image": "${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}",
          "tag": "${{ steps.meta.outputs.version }}",
          "commit": "${{ github.sha }}",
          "timestamp": "$(date -Iseconds)",
          "author": "${{ github.actor }}"
        }
        EOF
    
    - name: Upload deployment manifest
      uses: actions/upload-artifact@v3
      with:
        name: deployment-manifest
        path: deployment-manifest.json
        retention-days: 30

  deploy-to-nomad:
    needs: build-and-push
    runs-on: ubuntu-latest
    # Only run if all required secrets are available
    if: |
      vars.NOMAD_ADDR != '' && 
      secrets.NOMAD_TOKEN != '' &&
      secrets.NOMAD_CA_CERT != ''
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ vars.NOMAD_ADDR }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Download deployment manifest
      uses: actions/download-artifact@v3
      with:
        name: deployment-manifest
    
    - name: Setup Nomad CLI
      run: |
        # Download and install Nomad CLI
        curl -sL "https://releases.hashicorp.com/nomad/${NOMAD_VERSION}/nomad_${NOMAD_VERSION}_linux_amd64.zip" -o nomad.zip
        unzip -q nomad.zip
        sudo mv nomad /usr/local/bin/
        nomad version
        
        # Setup Nomad CA certificate if provided
        if [ -n "${{ secrets.NOMAD_CA_CERT }}" ]; then
          echo "${{ secrets.NOMAD_CA_CERT }}" > nomad-ca.crt
          export NOMAD_CACERT="$(pwd)/nomad-ca.crt"
        fi
    
    - name: Validate Nomad job specification
      run: |
        # Update job with new image
        IMAGE_DIGEST="${{ needs.build-and-push.outputs.image-digest }}"
        sed -i "s|image = \".*\"|image = \"${REGISTRY}/${IMAGE_NAME}@${IMAGE_DIGEST}\"|" cicd-app.nomad
        
        # Update Docker credentials in job file
        sed -i "s/\${DOCKER_USERNAME}/${{ secrets.DOCKER_USERNAME }}/g" cicd-app.nomad
        sed -i "s/\${DOCKER_TOKEN}/${{ secrets.DOCKER_TOKEN }}/g" cicd-app.nomad
        
        # Validate the job file
        NOMAD_ADDR="${{ vars.NOMAD_ADDR }}" \
        NOMAD_TOKEN="${{ secrets.NOMAD_TOKEN }}" \
        nomad job validate cicd-app.nomad
    
    - name: Plan Nomad deployment
      id: plan
      env:
        NOMAD_ADDR: ${{ vars.NOMAD_ADDR }}
        NOMAD_TOKEN: ${{ secrets.NOMAD_TOKEN }}
        NOMAD_NAMESPACE: ${{ vars.NOMAD_NAMESPACE || 'default' }}
        NOMAD_REGION: ${{ vars.NOMAD_REGION || 'global' }}
      run: |
        # Setup CA cert if provided
        if [ -n "${{ secrets.NOMAD_CA_CERT }}" ]; then
          echo "${{ secrets.NOMAD_CA_CERT }}" > nomad-ca.crt
          export NOMAD_CACERT="$(pwd)/nomad-ca.crt"
        fi
        
        # Create plan output
        nomad job plan \
          -diff \
          -policy-override \
          -json \
          cicd-app.nomad > plan.json
        
        # Extract check index
        CHECK_INDEX=$(jq -r '.JobModifyIndex // 0' plan.json)
        echo "check_index=${CHECK_INDEX}" >> $GITHUB_OUTPUT
        
        # Display plan diff for review
        echo "### Nomad Deployment Plan" >> $GITHUB_STEP_SUMMARY
        echo '```json' >> $GITHUB_STEP_SUMMARY
        jq -r '.Diff' plan.json >> $GITHUB_STEP_SUMMARY || echo "No diff available" >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
    
    - name: Deploy to Nomad
      id: deploy
      env:
        NOMAD_ADDR: ${{ vars.NOMAD_ADDR }}
        NOMAD_TOKEN: ${{ secrets.NOMAD_TOKEN }}
        NOMAD_NAMESPACE: ${{ vars.NOMAD_NAMESPACE || 'default' }}
        NOMAD_REGION: ${{ vars.NOMAD_REGION || 'global' }}
      run: |
        # Setup CA cert if provided
        if [ -n "${{ secrets.NOMAD_CA_CERT }}" ]; then
          echo "${{ secrets.NOMAD_CA_CERT }}" > nomad-ca.crt
          export NOMAD_CACERT="$(pwd)/nomad-ca.crt"
        fi
        
        # Run the deployment with check-index for safety
        nomad job run \
          -check-index="${{ steps.plan.outputs.check_index }}" \
          -json \
          cicd-app.nomad > deploy.json
        
        # Extract evaluation ID
        EVAL_ID=$(jq -r '.EvalID' deploy.json)
        echo "eval_id=${EVAL_ID}" >> $GITHUB_OUTPUT
        
        # Display deployment info
        echo "Deployment started with Evaluation ID: ${EVAL_ID}"
        echo "### Deployment Started" >> $GITHUB_STEP_SUMMARY
        echo "Evaluation ID: \`${EVAL_ID}\`" >> $GITHUB_STEP_SUMMARY
    
    - name: Monitor deployment
      env:
        NOMAD_ADDR: ${{ vars.NOMAD_ADDR }}
        NOMAD_TOKEN: ${{ secrets.NOMAD_TOKEN }}
      run: |
        # Setup CA cert if provided
        if [ -n "${{ secrets.NOMAD_CA_CERT }}" ]; then
          echo "${{ secrets.NOMAD_CA_CERT }}" > nomad-ca.crt
          export NOMAD_CACERT="$(pwd)/nomad-ca.crt"
        fi
        
        EVAL_ID="${{ steps.deploy.outputs.eval_id }}"
        MAX_WAIT=300  # 5 minutes timeout
        INTERVAL=10   # Check every 10 seconds
        ELAPSED=0
        
        echo "Monitoring evaluation ${EVAL_ID}..."
        
        while [ $ELAPSED -lt $MAX_WAIT ]; do
          # Get evaluation status
          STATUS=$(nomad eval status -json "${EVAL_ID}" | jq -r '.Status')
          
          echo "Evaluation status: ${STATUS}"
          
          if [ "${STATUS}" = "complete" ]; then
            echo "Deployment completed successfully!"
            
            # Get deployment status
            nomad job status cicd-app
            
            # Get allocation status
            nomad job status -verbose cicd-app | grep -A 10 "Allocations" || true
            
            echo "### Deployment Successful ✅" >> $GITHUB_STEP_SUMMARY
            exit 0
          elif [ "${STATUS}" = "failed" ] || [ "${STATUS}" = "canceled" ]; then
            echo "Deployment failed with status: ${STATUS}"
            
            # Get failure details
            nomad eval status -verbose "${EVAL_ID}"
            
            echo "### Deployment Failed ❌" >> $GITHUB_STEP_SUMMARY
            echo "Status: ${STATUS}" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
          
          sleep $INTERVAL
          ELAPSED=$((ELAPSED + INTERVAL))
        done
        
        echo "Deployment timeout after ${MAX_WAIT} seconds"
        echo "### Deployment Timeout ⏰" >> $GITHUB_STEP_SUMMARY
        exit 1
    
    - name: Verify deployment health
      env:
        NOMAD_ADDR: ${{ vars.NOMAD_ADDR }}
        NOMAD_TOKEN: ${{ secrets.NOMAD_TOKEN }}
      run: |
        # Setup CA cert if provided
        if [ -n "${{ secrets.NOMAD_CA_CERT }}" ]; then
          echo "${{ secrets.NOMAD_CA_CERT }}" > nomad-ca.crt
          export NOMAD_CACERT="$(pwd)/nomad-ca.crt"
        fi
        
        # Wait for allocations to be healthy
        sleep 30
        
        # Check allocation health
        JOB_STATUS=$(nomad job status -json cicd-app)
        HEALTHY=$(echo "$JOB_STATUS" | jq '[.Allocations[] | select(.ClientStatus == "running" and .DesiredStatus == "run")] | length')
        DESIRED=$(echo "$JOB_STATUS" | jq '.TaskGroups[0].Count // 1')
        
        echo "Health check: ${HEALTHY}/${DESIRED} allocations healthy"
        
        if [ "${HEALTHY}" -ge "${DESIRED}" ]; then
          echo "Deployment verified: ${HEALTHY}/${DESIRED} allocations healthy"
          echo "### Health Check Passed ✅" >> $GITHUB_STEP_SUMMARY
          echo "Healthy allocations: ${HEALTHY}/${DESIRED}" >> $GITHUB_STEP_SUMMARY
        else
          echo "Deployment unhealthy: only ${HEALTHY}/${DESIRED} allocations running"
          echo "### Health Check Failed ❌" >> $GITHUB_STEP_SUMMARY
          echo "Healthy allocations: ${HEALTHY}/${DESIRED}" >> $GITHUB_STEP_SUMMARY
          
          # Show allocation details for debugging
          nomad job status -verbose cicd-app
          exit 1
        fi
    
    - name: Create deployment annotation
      if: success()
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          await github.rest.repos.createDeployment({
            owner: context.repo.owner,
            repo: context.repo.repo,
            ref: context.sha,
            task: 'deploy',
            auto_merge: false,
            required_contexts: [],
            payload: {
              environment: '${{ github.event.inputs.environment || 'production' }}',
              image_digest: '${{ needs.build-and-push.outputs.image-digest }}',
              nomad_job: 'cicd-app'
            },
            environment: '${{ github.event.inputs.environment || 'production' }}',
            description: 'Nomad deployment via GitHub Actions'
          });
    
    - name: Rollback on failure
      if: failure() && steps.deploy.outputs.eval_id
      env:
        NOMAD_ADDR: ${{ vars.NOMAD_ADDR }}
        NOMAD_TOKEN: ${{ secrets.NOMAD_TOKEN }}
      run: |
        echo "Rolling back deployment..."
        
        # Setup CA cert if provided
        if [ -n "${{ secrets.NOMAD_CA_CERT }}" ]; then
          echo "${{ secrets.NOMAD_CA_CERT }}" > nomad-ca.crt
          export NOMAD_CACERT="$(pwd)/nomad-ca.crt"
        fi
        
        # Get the previous job version
        PREV_VERSION=$(nomad job history -json cicd-app | jq -r '.[1].Version // 0')
        
        if [ "${PREV_VERSION}" -gt 0 ]; then
          # Revert to previous version
          nomad job revert cicd-app "${PREV_VERSION}" -yes
          echo "Rolled back to version ${PREV_VERSION}"
          echo "### Rollback Completed 🔄" >> $GITHUB_STEP_SUMMARY
          echo "Reverted to version: ${PREV_VERSION}" >> $GITHUB_STEP_SUMMARY
        else
          echo "No previous version to rollback to"
          echo "### Rollback Skipped ⚠️" >> $GITHUB_STEP_SUMMARY
          echo "No previous version available" >> $GITHUB_STEP_SUMMARY
        fi

  # Fallback deployment to simple Docker if Nomad is not available
  deploy-docker-fallback:
    needs: build-and-push
    runs-on: ubuntu-latest
    # Only run if Nomad secrets are not available
    if: |
      vars.NOMAD_ADDR == '' || 
      secrets.NOMAD_TOKEN == '' ||
      secrets.DROPLET_HOST == ''
    environment:
      name: production-docker
      url: https://${{ secrets.DROPLET_HOST }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Deploy to DigitalOcean via Docker
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.DROPLET_HOST }}
        username: ${{ secrets.DROPLET_USER }}
        key: ${{ secrets.DROPLET_SSH_KEY }}
        port: ${{ secrets.SSH_PORT }}
        script_stop: true
        script: |
          set -euo pipefail
          
          # Configuration
          IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-and-push.outputs.image-digest }}"
          CONTAINER_NAME="cicd-app"
          
          # Login to Docker Hub
          echo "${{ secrets.DOCKER_TOKEN }}" | docker login -u "${{ secrets.DOCKER_USERNAME }}" --password-stdin
          
          # Pull new image
          docker pull "${IMAGE}"
          
          # Stop and remove old container
          docker stop "${CONTAINER_NAME}" || true
          docker rm "${CONTAINER_NAME}" || true
          
          # Start new container
          docker run -d \
            --name "${CONTAINER_NAME}" \
            --restart unless-stopped \
            --memory="512m" \
            --cpus="0.5" \
            --health-cmd="curl -f http://localhost:3000/health || exit 1" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-retries=3 \
            -p 80:3000 \
            -e NODE_ENV=production \
            -e PORT=3000 \
            "${IMAGE}"
          
          # Wait for health check
          sleep 30
          
          # Verify deployment
          if [ "$(docker inspect -f '{{.State.Health.Status}}' ${CONTAINER_NAME})" = "healthy" ]; then
            echo "Deployment successful!"
            docker ps --filter name="${CONTAINER_NAME}"
          else
            echo "Health check failed"
            docker logs "${CONTAINER_NAME}"
            exit 1
          fi
    
    - name: Verify deployment
      uses: appleboy/ssh-action@v0.1.5
      with:
        host: ${{ secrets.DROPLET_HOST }}
        username: ${{ secrets.DROPLET_USER }}
        key: ${{ secrets.DROPLET_SSH_KEY }}
        port: ${{ secrets.SSH_PORT }}
        script: |
          curl -f http://localhost/health || exit 1
          echo "Application is healthy and running!"
