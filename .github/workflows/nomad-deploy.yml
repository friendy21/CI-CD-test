# .github/workflows/main.yml - Fixed with Hardcoded Values
name: Secure CI/CD Pipeline

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  REGISTRY: docker.io
  IMAGE_NAME: friendy21/cicd-nomad-app
  # Hardcoded Docker credentials
  DOCKER_USERNAME: friendy21
  DOCKER_TOKEN: dckr_pat_TrLIn2QLrbBwY77IsPlkudXFK6U  # Replace with your actual Docker token
  # Hardcoded server details
  DROPLET_HOST: 137.184.85.0  # Your actual DigitalOcean server IP
  DROPLET_USER: root
  SSH_PORT: 22

jobs:
  security-scan:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner on filesystem
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'
        severity: 'CRITICAL,HIGH,MEDIUM'
        exit-code: '0'  # Don't fail the build on vulnerabilities
    
    - name: Upload Trivy results to GitHub Security
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  build-and-push:
    needs: security-scan
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      security-events: write
      id-token: write
    
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up QEMU
      uses: docker/setup-qemu-action@v3
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      with:
        driver-opts: |
          network=host
      
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ env.DOCKER_TOKEN }}
    
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=sha,prefix={{branch}}-
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value={{date 'YYYYMMDD-HHmmss'}}-{{sha}}
    
    - name: Build and push Docker image
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        platforms: linux/amd64,linux/arm64
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache
        cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:buildcache,mode=max
        build-args: |
          BUILDKIT_INLINE_CACHE=1
          VERSION=${{ github.sha }}
          BUILD_DATE=${{ github.event.head_commit.timestamp }}
        provenance: false  # Disable provenance to avoid issues
        sbom: false       # Disable SBOM to avoid issues
    
    - name: Scan pushed Docker image
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}
        format: 'sarif'
        output: 'docker-scan.sarif'
        severity: 'CRITICAL,HIGH'
        exit-code: '0'  # Don't fail after push, but report
    
    - name: Upload Docker scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'docker-scan.sarif'
        category: 'docker-image-scan'

  deploy:
    needs: build-and-push
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    environment:
      name: production
      url: http://${{ env.DROPLET_HOST }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Create SSH private key file
      run: |
        # Create hardcoded SSH private key (REPLACE WITH YOUR ACTUAL PRIVATE KEY)
        cat > ssh_private_key <<EOF
        -----BEGIN OPENSSH PRIVATE KEY-----
        YOUR_SSH_PRIVATE_KEY_CONTENT_HERE_REPLACE_THIS_WITH_YOUR_ACTUAL_PRIVATE_KEY
        -----END OPENSSH PRIVATE KEY-----
        EOF
        chmod 600 ssh_private_key
    
    - name: Deploy to DigitalOcean
      run: |
        # Deploy using SSH with hardcoded configuration
        ssh -o StrictHostKeyChecking=no -i ssh_private_key -p ${{ env.SSH_PORT }} ${{ env.DROPLET_USER }}@${{ env.DROPLET_HOST }} << 'ENDSSH'
        set -euo pipefail
        
        # Configuration
        IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ needs.build-and-push.outputs.image-digest }}"
        CONTAINER_NAME="app-container"
        NEW_CONTAINER="app-new-$(date +%s)"
        
        echo "Deploying image: ${IMAGE}"
        
        # Login to Docker Hub
        echo "${{ env.DOCKER_TOKEN }}" | docker login -u "${{ env.DOCKER_USERNAME }}" --password-stdin
        
        # Pull new image with retry logic
        for i in {1..3}; do
          if docker pull "${IMAGE}"; then
            echo "Image pulled successfully"
            break
          fi
          echo "Retry $i/3 failed, waiting..."
          sleep 5
        done
        
        # Start new container with health check
        docker run -d \
          --name "${NEW_CONTAINER}" \
          --restart unless-stopped \
          --memory="512m" \
          --cpus="0.5" \
          --health-cmd="curl -f http://localhost:3000/health || exit 1" \
          --health-interval=10s \
          --health-timeout=5s \
          --health-retries=3 \
          --health-start-period=30s \
          -p 3001:3000 \
          -e NODE_ENV=production \
          -e PORT=3000 \
          --label "deployment.timestamp=$(date -Iseconds)" \
          "${IMAGE}"
        
        # Wait for health check
        echo "Waiting for health check..."
        HEALTH_CHECK_RETRIES=30
        for i in $(seq 1 $HEALTH_CHECK_RETRIES); do
          HEALTH_STATUS=$(docker inspect -f '{{.State.Health.Status}}' ${NEW_CONTAINER} 2>/dev/null || echo "starting")
          echo "Health check attempt $i/$HEALTH_CHECK_RETRIES: $HEALTH_STATUS"
          
          if [ "$HEALTH_STATUS" == "healthy" ]; then
            echo "Health check passed!"
            
            # Perform traffic switch
            OLD_CONTAINER=$(docker ps -q -f name="^${CONTAINER_NAME}$" || true)
            
            if [ -n "${OLD_CONTAINER}" ]; then
              echo "Stopping old container..."
              docker stop --time=30 "${CONTAINER_NAME}" || true
              docker rm "${CONTAINER_NAME}" || true
            fi
            
            # Stop new container and restart with production port
            docker stop "${NEW_CONTAINER}"
            docker rm "${NEW_CONTAINER}"
            
            # Start final production container
            docker run -d \
              --name "${CONTAINER_NAME}" \
              --restart unless-stopped \
              --memory="512m" \
              --cpus="0.5" \
              --health-cmd="curl -f http://localhost:3000/health || exit 1" \
              --health-interval=30s \
              --health-timeout=10s \
              --health-retries=3 \
              -p 80:3000 \
              -e NODE_ENV=production \
              -e PORT=3000 \
              --label "deployment.timestamp=$(date -Iseconds)" \
              "${IMAGE}"
            
            echo "Deployment successful!"
            docker ps --filter name="${CONTAINER_NAME}"
            
            # Cleanup old images
            docker image prune -af --filter "until=24h" || true
            exit 0
          fi
          
          if [ $i -eq $HEALTH_CHECK_RETRIES ]; then
            echo "Health check failed after ${HEALTH_CHECK_RETRIES} attempts"
            docker logs "${NEW_CONTAINER}" --tail 50
            docker stop "${NEW_CONTAINER}" || true
            docker rm "${NEW_CONTAINER}" || true
            exit 1
          fi
          
          sleep 2
        done
        ENDSSH
    
    - name: Verify deployment
      run: |
        # Wait a moment for the container to fully start
        sleep 10
        
        # Test the health endpoint
        if curl -f --max-time 30 http://${{ env.DROPLET_HOST }}/health; then
          echo "Application is healthy and running!"
          echo "### Deployment Successful ✅" >> $GITHUB_STEP_SUMMARY
          echo "Application URL: http://${{ env.DROPLET_HOST }}" >> $GITHUB_STEP_SUMMARY
        else
          echo "Application health check failed"
          echo "### Deployment Failed ❌" >> $GITHUB_STEP_SUMMARY
          
          # Get container logs for debugging
          ssh -o StrictHostKeyChecking=no -i ssh_private_key -p ${{ env.SSH_PORT }} ${{ env.DROPLET_USER }}@${{ env.DROPLET_HOST }} \
            "docker logs app-container --tail 50" || true
